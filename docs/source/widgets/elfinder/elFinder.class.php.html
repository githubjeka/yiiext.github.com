<html>
    <head>
        <script type="text/javascript" src="../../../js/jquery-1.4.2.min.js"></script>
        <script type="text/javascript" src="../../../syntax_highlighter/scripts/shCore.js"></script>
        <script type="text/javascript" src="../../../syntax_highlighter/scripts/shBrushJScript.js"></script>
        <script type="text/javascript" src="../../../syntax_highlighter/scripts/shBrushPhp.js"></script>
        <script type="text/javascript" src="../../../syntax_highlighter/scripts/shBrushXml.js"></script>
        <link href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet" type="text/css" />
        <link href="../../../syntax_highlighter/styles/shCoreEclipse.css" rel="stylesheet" type="text/css" />
        <link href="../../../syntax_highlighter/styles/shThemeWordpress.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

// set locale to UTF8 to correct multibyte characters 
setlocale(LC_ALL, 'en_US.UTF8');

interface elFinderILogger {
	public function log($cmd, $ok, $context, $err='', $errorData = array());
}

class elFinder {
	
	/**
	 * object options
	 *
	 * @var array
	 **/
	private $_options = array(
		'root'         =&gt; '',           // path to root directory
		'URL'          =&gt; '',           // root directory URL
		'rootAlias'    =&gt; 'Home',       // display this instead of root directory name
		'disabled'     =&gt; array(),      // list of not allowed commands
		'dotFiles'     =&gt; false,        // display dot files
		'dirSize'      =&gt; true,         // count total directories sizes
		'fileMode'     =&gt; 0666,         // new files mode
		'dirMode'      =&gt; 0777,         // new folders mode
		'mimeDetect'   =&gt; 'auto',       // files mimetypes detection method (finfo, mime_content_type, linux (file -ib), bsd (file -Ib), internal (by extensions))
		'uploadAllow'  =&gt; array(),      // mimetypes which allowed to upload
		'uploadDeny'   =&gt; array(),      // mimetypes which not allowed to upload
		'uploadOrder'  =&gt; 'deny,allow', // order to proccess uploadAllow and uploadAllow options
		'imgLib'       =&gt; 'auto',       // image manipulation library (imagick, mogrify, gd)
		'tmbDir'       =&gt; '.tmb',       // directory name for image thumbnails. Set to &quot;&quot; to avoid thumbnails generation
		'tmbCleanProb' =&gt; 1,            // how frequiently clean thumbnails dir (0 - never, 200 - every init request)
		'tmbAtOnce'    =&gt; 5,            // number of thumbnails to generate per request
		'tmbSize'      =&gt; 48,           // images thumbnails size (px)
		'fileURL'      =&gt; true,         // display file URL in &quot;get info&quot;
		'dateFormat'   =&gt; 'j M Y H:i',  // file modification date format
		'logger'       =&gt; null,         // object logger
		'aclObj'       =&gt; null,         // acl object (not implemented yet)
		'aclRole'      =&gt; 'user',       // role for acl
		'defaults'     =&gt; array(        // default permisions
			'read'   =&gt; true,
			'write'  =&gt; true,
			'rm'     =&gt; true
			),
		'perms'        =&gt; array(),      // individual folders/files permisions     
		'debug'        =&gt; false,        // send debug to client
		'archiveMimes' =&gt; array(),      // allowed archive's mimetypes to create. Leave empty for all available types.
		'archivers'    =&gt; array()       // info about archivers to use. See example below. Leave empty for auto detect
		// 'archivers' =&gt; array(
		// 	'create' =&gt; array(
		// 		'application/x-gzip' =&gt; array(
		// 			'cmd' =&gt; 'tar',
		// 			'argc' =&gt; '-czf',
		// 			'ext'  =&gt; 'tar.gz'
		// 			)
		// 		),
		// 	'extract' =&gt; array(
		// 		'application/x-gzip' =&gt; array(
		// 			'cmd'  =&gt; 'tar',
		// 			'argc' =&gt; '-xzf',
		// 			'ext'  =&gt; 'tar.gz'
		// 			),
		// 		'application/x-bzip2' =&gt; array(
		// 			'cmd'  =&gt; 'tar',
		// 			'argc' =&gt; '-xjf',
		// 			'ext'  =&gt; 'tar.bz'
		// 			)
		// 		)
		// 	)
		);
	
	/**
	 * mapping $_GET['cmd]/$_POST['cmd] to class methods
	 *
	 * @var array
	 **/
	private $_commands = array(
		'open'      =&gt; '_open',
		'reload'    =&gt; '_reload',
		'mkdir'     =&gt; '_mkdir',
		'mkfile'    =&gt; '_mkfile',
		'rename'    =&gt; '_rename',
		'upload'    =&gt; '_upload',
		'paste'     =&gt; '_paste',
		'rm'        =&gt; '_rm',
		'duplicate' =&gt; '_duplicate',
		'read'      =&gt; '_fread',
		'edit'      =&gt; '_edit',
		'archive'   =&gt; '_archive',
		'extract'   =&gt; '_extract',
		'resize'    =&gt; '_resize',
		'tmb'       =&gt; '_thumbnails',
		'ping'      =&gt; '_ping'
		);
		
	/**
	 * List of commands to log
	 *
	 * @var string
	 **/
	public $_loggedCommands = array('mkdir', 'mkfile', 'rename', 'upload', 'paste', 'rm', 'duplicate', 'edit', 'resize');
	
	/**
	 * Context to log command
	 *
	 * @var string
	 **/
	private $_logContext = array();
		
	/**
	 * extensions/mimetypes for _mimetypeDetect = 'internal' 
	 *
	 * @var array
	 **/
	private $_mimeTypes = array(
		//applications
		'ai'    =&gt; 'application/postscript',
		'eps'   =&gt; 'application/postscript',
		'exe'   =&gt; 'application/octet-stream',
		'doc'   =&gt; 'application/vnd.ms-word',
		'xls'   =&gt; 'application/vnd.ms-excel',
		'ppt'   =&gt; 'application/vnd.ms-powerpoint',
		'pps'   =&gt; 'application/vnd.ms-powerpoint',
		'pdf'   =&gt; 'application/pdf',
		'xml'   =&gt; 'application/xml',
		'odt'   =&gt; 'application/vnd.oasis.opendocument.text',
		'swf'   =&gt; 'application/x-shockwave-flash',
		// archives
		'gz'    =&gt; 'application/x-gzip',
		'tgz'   =&gt; 'application/x-gzip',
		'bz'    =&gt; 'application/x-bzip2',
		'bz2'   =&gt; 'application/x-bzip2',
		'tbz'   =&gt; 'application/x-bzip2',
		'zip'   =&gt; 'application/zip',
		'rar'   =&gt; 'application/x-rar',
		'tar'   =&gt; 'application/x-tar',
		'7z'    =&gt; 'application/x-7z-compressed',
		// texts
		'txt'   =&gt; 'text/plain',
		'php'   =&gt; 'text/x-php',
		'html'  =&gt; 'text/html',
		'htm'   =&gt; 'text/html',
		'js'    =&gt; 'text/javascript',
		'css'   =&gt; 'text/css',
		'rtf'   =&gt; 'text/rtf',
		'rtfd'  =&gt; 'text/rtfd',
		'py'    =&gt; 'text/x-python',
		'java'  =&gt; 'text/x-java-source',
		'rb'    =&gt; 'text/x-ruby',
		'sh'    =&gt; 'text/x-shellscript',
		'pl'    =&gt; 'text/x-perl',
		'sql'   =&gt; 'text/x-sql',
		// images
		'bmp'   =&gt; 'image/x-ms-bmp',
		'jpg'   =&gt; 'image/jpeg',
		'jpeg'  =&gt; 'image/jpeg',
		'gif'   =&gt; 'image/gif',
		'png'   =&gt; 'image/png',
		'tif'   =&gt; 'image/tiff',
		'tiff'  =&gt; 'image/tiff',
		'tga'   =&gt; 'image/x-targa',
		'psd'   =&gt; 'image/vnd.adobe.photoshop',
		//audio
		'mp3'   =&gt; 'audio/mpeg',
		'mid'   =&gt; 'audio/midi',
		'ogg'   =&gt; 'audio/ogg',
		'mp4a'  =&gt; 'audio/mp4',
		'wav'   =&gt; 'audio/wav',
		'wma'   =&gt; 'audio/x-ms-wma',
		// video
		'avi'   =&gt; 'video/x-msvideo',
		'dv'    =&gt; 'video/x-dv',
		'mp4'   =&gt; 'video/mp4',
		'mpeg'  =&gt; 'video/mpeg',
		'mpg'   =&gt; 'video/mpeg',
		'mov'   =&gt; 'video/quicktime',
		'wm'    =&gt; 'video/x-ms-wmv',
		'flv'   =&gt; 'video/x-flv',
		'mkv'   =&gt; 'video/x-matroska'
		);
	
	/**
	 * undocumented class variable
	 *
	 * @var string
	 **/
	private $_time = 0;
				
	/**
	 * Additional data about error
	 *
	 * @var array
	 **/
	private $_errorData = array();
		
	/**
	 * undocumented class variable
	 *
	 * @var string
	 **/
	private $_fakeRoot = '';
	
	/**
	 * Command result to send to client
	 *
	 * @var array
	 **/
	private $_result = array();
		
	/**
	 * undocumented class variable
	 *
	 * @var string
	 **/
	private $_today = 0;
			
	/**
	 * undocumented class variable
	 *
	 * @var string
	 **/
	private $_yesterday = 0;
			
	/**
	 * constructor
	 *
	 * @param  array object options
	 * @return void
	 **/
	public function __construct($options=array()) {
		
		foreach ($this-&gt;_options as $k=&gt;$v) {
			if (isset($options[$k])) {
				$this-&gt;_options[$k] = is_array($this-&gt;_options[$k]) 
					? array_merge($this-&gt;_options[$k], $options[$k]) 
					: $options[$k];
			}
		}

		if (substr($this-&gt;_options['root'], -1) == DIRECTORY_SEPARATOR) {
			$this-&gt;_options['root'] = substr($this-&gt;_options['root'], 0, -1);
		}

		$this-&gt;_time = $this-&gt;_options['debug'] ? $this-&gt;_utime() : 0;

		$this-&gt;_fakeRoot = !$this-&gt;_options['rootAlias'] 
			? $this-&gt;_options['root'] 
			: dirname($this-&gt;_options['root']).DIRECTORY_SEPARATOR.$this-&gt;_options['rootAlias'];
			
		if (!empty($this-&gt;_options['disabled'])) {
			$no = array('open', 'reload', 'tmb', 'ping');
			foreach ($this-&gt;_options['disabled'] as $k =&gt; $c) {
				if (!isset($this-&gt;_commands[$c]) || in_array($c, $no)) {
					unset($this-&gt;_options['disabled'][$k]);
				} else {
					unset($this-&gt;_commands[$c]);
				}
			}
		}
				
		if ($this-&gt;_options['tmbDir']) {
			$tmbDir = $this-&gt;_options['root'].DIRECTORY_SEPARATOR.$this-&gt;_options['tmbDir'];
			$this-&gt;_options['tmbDir'] = is_dir($tmbDir) || @mkdir($tmbDir, $this-&gt;_options['dirMode']) ? $tmbDir : '';
		}
		if ($this-&gt;_options['tmbDir']) {
			if (!in_array($this-&gt;_options['imgLib'], array('imagick', 'mogrify', 'gd'))) {
				$this-&gt;_options['imgLib'] = $this-&gt;_getImgLib();
			}
		}
		$this-&gt;_today = mktime(0,0,0, date('m'), date('d'), date('Y'));
		$this-&gt;_yesterday = $this-&gt;_today-86400;
	}

	/**
	 * Proccess client request and output json
	 *
	 * @return void
	 **/
	public function run() {
		if (empty($this-&gt;_options['root']) || !is_dir($this-&gt;_options['root'])) {
			exit(json_encode(array('error' =&gt; 'Invalid backend configuration')));
		}
		if (!$this-&gt;_isAllowed($this-&gt;_options['root'], 'read')) {
			exit(json_encode(array('error' =&gt; 'Access denied')));
		}
		
		$cmd = '';
		if (!empty($_POST['cmd'])) {
			$cmd = trim($_POST['cmd']);
		} elseif (!empty($_GET['cmd'])) {
			$cmd = trim($_GET['cmd']);
		}
		if (!$cmd &amp;&amp; $_SERVER[&quot;REQUEST_METHOD&quot;] == 'POST') {
			header(&quot;Content-Type: text/html&quot;);
			$this-&gt;_result['error'] = 'Data exceeds the maximum allowed size';
			exit(json_encode($this-&gt;_result));
		}
		
		if ($cmd &amp;&amp; (empty($this-&gt;_commands[$cmd]) || !method_exists($this, $this-&gt;_commands[$cmd]))) {
			exit(json_encode(array('error' =&gt; 'Unknown command')));
		}
		
		if (isset($_GET['init'])) {
			
			$ts = $this-&gt;_utime();
			$this-&gt;_result['disabled'] = $this-&gt;_options['disabled'];
			
			$this-&gt;_result['params'] = array(
				'dotFiles'   =&gt; $this-&gt;_options['dotFiles'],
				'uplMaxSize' =&gt; ini_get('upload_max_filesize'),
				'archives'   =&gt; array(),
				'extract'    =&gt; array(),
				'url'        =&gt; $this-&gt;_options['fileURL'] ? $this-&gt;_options['URL'] : ''
				);
			if (isset($this-&gt;_commands['archive']) || isset($this-&gt;_commands['extract'])) {
				$this-&gt;_checkArchivers();
				if (isset($this-&gt;_commands['archive'])) {
					$this-&gt;_result['params']['archives'] = $this-&gt;_options['archiveMimes'];
				}
				if (isset($this-&gt;_commands['extract'])) {
					$this-&gt;_result['params']['extract'] = array_keys($this-&gt;_options['archivers']['extract']);
				}
			}
			// clean thumbnails dir
			if ($this-&gt;_options['tmbDir']) {
				srand((double) microtime() * 1000000);
				if (rand(1, 200) &lt;= $this-&gt;_options['tmbCleanProb']) {
					$ts2 = $this-&gt;_utime();
					$ls = scandir($this-&gt;_options['tmbDir']);
					for ($i=0, $s = count($ls); $i &lt; $s; $i++) { 
						if ('.' != $ls[$i] &amp;&amp; '..' != $ls[$i]) {
							@unlink($this-&gt;_options['tmbDir'].DIRECTORY_SEPARATOR.$ls[$i]);
						}
					}
				}
			}
			
		}
		
		if ($cmd) {
			$this-&gt;{$this-&gt;_commands[$cmd]}();
		} else {
			$this-&gt;_open();
		}

		if ($this-&gt;_options['debug']) {
			$this-&gt;_result['debug'] = array(
				'time'       =&gt; $this-&gt;_utime() - $this-&gt;_time,
				'mimeDetect' =&gt; $this-&gt;_options['mimeDetect'],
				'imgLib'     =&gt; $this-&gt;_options['imgLib']
				);
			if ($this-&gt;_options['dirSize']) {
				$this-&gt;_result['debug']['dirSize'] = true;
				$this-&gt;_result['debug']['du'] = @$this-&gt;_options['du'];
			}
			
		}
		header(&quot;Content-Type: &quot;.($cmd == 'upload' ? 'text/html' : 'application/json'));
		header(&quot;Connection: close&quot;);
		echo json_encode($this-&gt;_result);
		
		if (!empty($this-&gt;_options['logger']) &amp;&amp; in_array($cmd, $this-&gt;_loggedCommands)) {
			$this-&gt;_options['logger']-&gt;log($cmd, empty($this-&gt;_result['error']), $this-&gt;_logContext, !empty($this-&gt;_result['error']) ? $this-&gt;_result['error'] : '', !empty($this-&gt;_result['errorData']) ? $this-&gt;_result['errorData'] : array()); 
		}
		exit();
	}

	
	/************************************************************/
	/**                   elFinder commands                    **/
	/************************************************************/
	
	/**
	 * Return current dir content to client or output file content to browser
	 *
	 * @return void
	 **/
	private function _open()
	{
		if (isset($_GET['current'])) { // read file
			if (empty($_GET['current']) 
			||  empty($_GET['target'])
			||  false == ($dir = $this-&gt;_findDir(trim($_GET['current'])))
			||  false == ($file = $this-&gt;_find(trim($_GET['target']), $dir))
			||  is_dir($file)
			) {
				header('HTTP/1.x 404 Not Found'); 
				exit('File not found');
			}
			if (!$this-&gt;_isAllowed($dir, 'read') || !$this-&gt;_isAllowed($file, 'read')) {
				header('HTTP/1.x 403 Access Denied'); 
				exit('Access denied');
			}
			
			if (filetype($file) == 'link') {
				$file = $this-&gt;_readlink($file);
				if (!$file || is_dir($file)) {
					header('HTTP/1.x 404 Not Found'); 
					exit('File not found');
				}
				if (!$this-&gt;_isAllowed(dirname($file), 'read') || !$this-&gt;_isAllowed($file, 'read')) {
					header('HTTP/1.x 403 Access Denied'); 
					exit('Access denied');
				}
			}
			
			$mime  = $this-&gt;_mimetype($file);
			$parts = explode('/', $mime);
			$disp  = $parts[0] == 'image' || $parts[0] == 'text' ? 'inline' : 'attachments';
			
			header(&quot;Content-Type: &quot;.$mime);
			header(&quot;Content-Disposition: &quot;.$disp.&quot;; filename=&quot;.basename($file));
			header(&quot;Content-Location: &quot;.str_replace($this-&gt;_options['root'], '', $file));
			header('Content-Transfer-Encoding: binary');
			header(&quot;Content-Length: &quot;.filesize($file));
			header(&quot;Connection: close&quot;);
			readfile($file);
			exit();
			
		} else { // enter directory
			$path = $this-&gt;_options['root'];
			if (!empty($_GET['target'])) {
				if (false == ($p = $this-&gt;_findDir(trim($_GET['target'])))) {
					if (!isset($_GET['init'])) {
						$this-&gt;_result['error'] = 'Invalid parameters';
					}
				} elseif (!$this-&gt;_isAllowed($p, 'read')) {
					if (!isset($_GET['init'])) {
						$this-&gt;_result['error'] = 'Access denied';
					}
				} else {
					$path = $p;
				}
			}
			$this-&gt;_content($path, isset($_GET['tree']));
		}
	}
	
	
	/**
	 * Rename file/folder
	 *
	 * @return void
	 **/
	private function _rename()
	{
		if (empty($_GET['current']) 
		||  empty($_GET['target'])
		||  false == ($dir = $this-&gt;_findDir(trim($_GET['current'])))
		||  false == ($target = $this-&gt;_find(trim($_GET['target']), $dir))
		) {
			$this-&gt;_result['error'] = 'File not found';
		} elseif (false == ($name = $this-&gt;_checkName($_GET['name'])) ) {
			$this-&gt;_result['error'] = 'Invalid name';
		} elseif (!$this-&gt;_isAllowed($dir, 'write')) {
			$this-&gt;_result['error'] = 'Access denied';
		} elseif (file_exists($dir.DIRECTORY_SEPARATOR.$name)) {
			$this-&gt;_result['error'] = 'File or folder with the same name already exists';
		} elseif (!rename($target, $dir.DIRECTORY_SEPARATOR.$name)) {
			$this-&gt;_result['error'] = 'Unable to rename file';
		} else {
			$this-&gt;_rmTmb($target);
			$this-&gt;_logContext['from'] = $target;
			$this-&gt;_logContext['to']   = $dir.DIRECTORY_SEPARATOR.$name;
			$this-&gt;_result['select']   = array($this-&gt;_hash($dir.DIRECTORY_SEPARATOR.$name));
			$this-&gt;_content($dir, is_dir($dir.DIRECTORY_SEPARATOR.$name));
		}
	}
	
	
	/**
	 * Create new folder
	 *
	 * @return void
	 **/
	private function _mkdir()
	{
		if (empty($_GET['current']) ||  false == ($dir = $this-&gt;_findDir(trim($_GET['current'])))) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		} 
		$this-&gt;_logContext['dir'] = $dir.DIRECTORY_SEPARATOR.$_GET['name'];
		if (!$this-&gt;_isAllowed($dir, 'write')) {
			$this-&gt;_result['error'] = 'Access denied';
		} elseif (false == ($name = $this-&gt;_checkName($_GET['name'])) ) {
			$this-&gt;_result['error'] = 'Invalid name';
		} elseif (file_exists($dir.DIRECTORY_SEPARATOR.$name)) {
			$this-&gt;_result['error'] = 'File or folder with the same name already exists';
		} elseif (!@mkdir($dir.DIRECTORY_SEPARATOR.$name, $this-&gt;_options['dirMode'])) {
			$this-&gt;_result['error'] = 'Unable to create folder';
		} else {
			$this-&gt;_logContext['dir'] = $dir.DIRECTORY_SEPARATOR.$name;
			$this-&gt;_result['select']  = array($this-&gt;_hash($dir.DIRECTORY_SEPARATOR.$name));
			$this-&gt;_content($dir, true);
		}
	}
	
	/**
	 * Create new empty file
	 *
	 * @return void
	 **/
	private function _mkfile()
	{
		if (empty($_GET['current']) 
		||  false == ($dir = $this-&gt;_findDir(trim($_GET['current'])))) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		} 
		$this-&gt;_logContext['file'] = $dir.DIRECTORY_SEPARATOR.$_GET['name'];
		if (!$this-&gt;_isAllowed($dir, 'write')) {
			$this-&gt;_result['error'] = 'Access denied';
		} elseif (false == ($name = $this-&gt;_checkName($_GET['name'])) ) {
			$this-&gt;_result['error'] = 'Invalid name';
		} elseif (file_exists($dir.DIRECTORY_SEPARATOR.$name)) {
			$this-&gt;_result['error'] = 'File or folder with the same name already exists';
		} else {
			$f = $dir.DIRECTORY_SEPARATOR.$name;
			$this-&gt;_logContext['file'] = $f;
			if (false != ($fp = @fopen($f, 'wb'))) {
				fwrite($fp, &quot;&quot;);
				fclose($fp);
				$this-&gt;_result['select'] = array($this-&gt;_hash($dir.DIRECTORY_SEPARATOR.$name));
				$this-&gt;_content($dir);
			} else {
				$this-&gt;_result['error'] = 'Unable to create file';
			}
		} 
	}
	
	/**
	 * Remove files/folders
	 *
	 * @return void
	 **/
	private function _rm()
	{
		if (empty($_GET['current']) 
		||  false == ($dir = $this-&gt;_findDir(trim($_GET['current']))) 
		|| (empty($_GET['targets']) || !is_array($_GET['targets']))) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		} 

		$this-&gt;_logContext['targets'] = array();
		foreach ($_GET['targets'] as $hash) {
			if (false != ($f = $this-&gt;_find($hash, $dir))) {
				$this-&gt;_remove($f);
				$this-&gt;_logContext['targets'][] = $f;
			}
		}
		if (!empty($this-&gt;_result['errorData'])) {
			$this-&gt;_result['error'] = 'Unable to remove file';
		}
		$this-&gt;_content($dir, true);
	}
	
	/**
	 * Upload files
	 *
	 * @return void
	 **/
	private function _upload()
	{

		if (empty($_POST['current']) 
		|| false == ($dir = $this-&gt;_findDir(trim($_POST['current'])))) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		} 
		if (!$this-&gt;_isAllowed($dir, 'write')) {
			return $this-&gt;_result['error'] = 'Access denied';
		}
		if (empty($_FILES['upload']))
		{
			return $this-&gt;_result['error'] = 'No file to upload';
		}
		
		$this-&gt;_logContext['upload'] = array();
		$this-&gt;_result['select'] = array();
		$total = 0;
		for ($i=0, $s = count($_FILES['upload']['name']); $i &lt; $s; $i++) { 
			if (!empty($_FILES['upload']['name'][$i])) {
				$total++;
				$this-&gt;_logContext['upload'][] = $_FILES['upload']['name'][$i];
				if ($_FILES['upload']['error'][$i] &gt; 0) {
					$error = 'Unable to upload file';
					switch ($_FILES['upload']['error'][$i]) {
						case UPLOAD_ERR_INI_SIZE:
						case UPLOAD_ERR_FORM_SIZE:
							$error = 'File exceeds the maximum allowed filesize';
							break;
						case UPLOAD_ERR_EXTENSION:
							$error = 'Not allowed file type';
							break;
					}
					$this-&gt;_errorData($_FILES['upload']['name'][$i], $error);
				} elseif (false == ($name = $this-&gt;_checkName($_FILES['upload']['name'][$i]))) {
					$this-&gt;_errorData($_FILES['upload']['name'][$i], 'Invalid name');
				} elseif (!$this-&gt;_isUploadAllow($_FILES['upload']['name'][$i], $_FILES['upload']['tmp_name'][$i])) {
					$this-&gt;_errorData($_FILES['upload']['name'][$i], 'Not allowed file type');					
				} else {
					$file = $dir.DIRECTORY_SEPARATOR.$_FILES['upload']['name'][$i];
					if (!@move_uploaded_file($_FILES['upload']['tmp_name'][$i], $file)) {
						$this-&gt;_errorData($_FILES['upload']['name'][$i], 'Unable to save uploaded file');	
					} else {
						@chmod($file, $this-&gt;_options['fileMode']);
						$this-&gt;_result['select'][] = $this-&gt;_hash($file);
					}
				}
			}
		}
		
		$errCnt = !empty($this-&gt;_result['errorData']) ? count($this-&gt;_result['errorData']) : 0;
		
		if ($errCnt == $total) {
			$this-&gt;_result['error'] = 'Unable to upload files';
		} else {
			if ($errCnt&gt;0) {
				$this-&gt;_result['error'] = 'Some files was not uploaded';	
			}
			$this-&gt;_content($dir);
		}
		
	}
	
	/**
	 * Copy/move files/folders
	 *
	 * @return void
	 **/
	private function _paste()
	{
		if (empty($_GET['current']) 
		|| false == ($current = $this-&gt;_findDir(trim($_GET['current'])))
		|| empty($_GET['src'])
		|| false == ($src = $this-&gt;_findDir(trim($_GET['src'])))
		|| empty($_GET['dst'])
		|| false == ($dst = $this-&gt;_findDir(trim($_GET['dst'])))
		|| empty($_GET['targets']) || !is_array($_GET['targets'])
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		$cut = !empty($_GET['cut']);
		$this-&gt;_logContext['src']  = array();
		$this-&gt;_logContext['dest'] = $dst;
		$this-&gt;_logContext['cut']  = $cut;
		
		
		if (!$this-&gt;_isAllowed($dst, 'write') || !$this-&gt;_isAllowed($src, 'read')) {
			return $this-&gt;_result['error'] = 'Access denied';
		}

		foreach ($_GET['targets'] as $hash) {
			if (false == ($f = $this-&gt;_find($hash, $src))) {
				return $this-&gt;_result['error'] = 'File not found' &amp;&amp; $this-&gt;_content($current, true);
			}
			$this-&gt;_logContext['src'][] = $f;
			$_dst = $dst.DIRECTORY_SEPARATOR.basename($f);

			if (0 === strpos($dst, $f)) {
				return $this-&gt;_result['error'] = 'Unable to copy into itself' &amp;&amp; $this-&gt;_content($current, true);
			} elseif (file_exists($_dst)) {
				return $this-&gt;_result['error'] = 'File or folder with the same name already exists' &amp;&amp; $this-&gt;_content($current, true);
			} elseif ($cut &amp;&amp; !$this-&gt;_isAllowed($f, 'rm')) {
				return $this-&gt;_result['error'] = 'Access denied' &amp;&amp; $this-&gt;_content($current, true);
			}

			if ($cut) {
				if (!@rename($f, $_dst)) {
					return $this-&gt;_result['error'] = 'Unable to move files' &amp;&amp; $this-&gt;_content($current, true);
				} elseif (!is_dir($f)) {
					$this-&gt;_rmTmb($f);
				}
			} elseif (!$this-&gt;_copy($f, $_dst)) {
				return $this-&gt;_result['error'] = 'Unable to copy files' &amp;&amp; $this-&gt;_content($current, true);
			}
		}
		$this-&gt;_content($current, true);
	}
	
	/**
	 * Create file/folder copy with suffix - &quot;copy&quot;
	 *
	 * @return void
	 **/
	private function _duplicate()
	{
		if (empty($_GET['current']) 
		|| false == ($current = $this-&gt;_findDir(trim($_GET['current'])))
		|| empty($_GET['target'])
		|| false == ($target = $this-&gt;_find(trim($_GET['target']), $current))
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		$this-&gt;_logContext['target'] = $target;
		if (!$this-&gt;_isAllowed($current, 'write') || !$this-&gt;_isAllowed($target, 'read')) {
			return $this-&gt;_result['error'] = 'Access denied';
		}
		$dup = $this-&gt;_uniqueName($target);
		if (!$this-&gt;_copy($target, $dup)) {
			return $this-&gt;_result['error'] = 'Unable to create file copy';
		}
		$this-&gt;_result['select'] = array($this-&gt;_hash($dup));
		$this-&gt;_content($current, is_dir($target));
	}
	
	/**
	 * Resize image
	 *
	 * @return void
	 **/
	private function _resize()
	{
		if (empty($_GET['current']) 
		|| false == ($current = $this-&gt;_findDir(trim($_GET['current'])))
		|| empty($_GET['target'])
		|| false == ($target = $this-&gt;_find(trim($_GET['target']), $current))
		|| empty($_GET['width'])  || 0 &gt;= ($width  = intval($_GET['width']))
		|| empty($_GET['height']) || 0 &gt;= ($height = intval($_GET['height']))
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		$this-&gt;_logContext = array(
			'target' =&gt; $target,
			'width'  =&gt; $width,
			'height' =&gt; $height
			);
		if (!$this-&gt;_isAllowed($target, 'write')) {
			return $this-&gt;_result['error'] = 'Access denied';
		} 
		if (0 !== strpos($this-&gt;_mimetype($target), 'image')) {
			return $this-&gt;_result['error'] = 'File is not an image';
		}
		if (!$this-&gt;_resizeImg($target, $width, $height)) {
			return $this-&gt;_result['error'] = 'Unable to resize image';
		} 
		$this-&gt;_result['select'] = array($this-&gt;_hash($target));
		$this-&gt;_content($current);
	}
		
	/**
	 * Create images thumbnails 
	 *
	 * @return void
	 **/
	private function _thumbnails()
	{
		if (!empty($this-&gt;_options['tmbDir']) &amp;&amp; !empty($_GET['current']) &amp;&amp; false != ($current = $this-&gt;_findDir(trim($_GET['current'])))) {
			$this-&gt;_result['current'] = $this-&gt;_hash($current);
			$this-&gt;_result['images'] = array();
			$ls = scandir($current);
			$cnt = 0;
			$max = $this-&gt;_options['tmbAtOnce'] &gt; 0 ? intval($this-&gt;_options['tmbAtOnce']) : 5;
			for ($i=0; $i &lt; count($ls); $i++) { 
				if ($this-&gt;_isAccepted($ls[$i])) {
					$path = $current.DIRECTORY_SEPARATOR.$ls[$i];
					if (is_readable($path) &amp;&amp; $this-&gt;_canCreateTmb($this-&gt;_mimetype($path))) {
						$tmb = $this-&gt;_tmbPath($path);
						if (!file_exists($tmb)) {
							if ($cnt&gt;=$max) {
								return $this-&gt;_result['tmb'] = true; 
							} elseif ($this-&gt;_tmb($path, $tmb)) {
								$this-&gt;_result['images'][$this-&gt;_hash($path)] = $this-&gt;_path2url($tmb);
								$cnt++;
							}
						}
					}
				}
			}
		} 
	}
	
	/**
	 * Return file content to client
	 *
	 * @return void
	 **/
	private function _fread()
	{
		if (empty($_GET['current']) 
		|| false == ($current = $this-&gt;_findDir(trim($_GET['current'])))
		|| empty($_GET['target'])
		|| false == ($target = $this-&gt;_find(trim($_GET['target']), $current))
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		if (!$this-&gt;_isAllowed($target, 'read')) {
			return $this-&gt;_result['error'] = 'Access denied';
		}
		$this-&gt;_result['content'] = @file_get_contents($target);
	}
	
	/**
	 * Save data into text file. 
	 *
	 * @return void
	 **/
	private function _edit()
	{
		if (empty($_POST['current']) 
		|| false == ($current = $this-&gt;_findDir(trim($_POST['current'])))
		|| empty($_POST['target'])
		|| false == ($target = $this-&gt;_find(trim($_POST['target']), $current))
		|| !isset($_POST['content'])
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		$this-&gt;_logContext['target'] = $target;
		if (!$this-&gt;_isAllowed($target, 'write')) {
			return $this-&gt;_result['error'] = 'Access denied';
		}
		if (false === file_put_contents($target, trim($_POST['content']))) {
			return $this-&gt;_result['error'] = 'Unable to write to file';
		}
		$this-&gt;_result['target'] = $this-&gt;_info($target);
		// $this-&gt;_result['select'] = array($this-&gt;_hash($target));
	}
	
	/**
	 * Create archive of selected type
	 *
	 * @return void
	 **/
	private function _archive()
	{
		$this-&gt;_checkArchivers();
		if (empty($this-&gt;_options['archivers']['create']) 
		|| empty($_GET['type']) 
		|| empty($this-&gt;_options['archivers']['create'][$_GET['type']])
		|| !in_array($_GET['type'], $this-&gt;_options['archiveMimes'])) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		
		if (empty($_GET['current']) 
		||  empty($_GET['targets'])
		|| !is_array($_GET['targets'])
		||  false == ($dir = $this-&gt;_findDir(trim($_GET['current'])))
		|| !$this-&gt;_isAllowed($dir, 'write')
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		
		$files = array();
		$argc  = '';
		foreach ($_GET['targets'] as $hash) {
			if (false == ($f = $this-&gt;_find($hash, $dir))) {
				return $this-&gt;_result['error'] = 'File not found';
			}
			$files[] = $f;
			$argc .= escapeshellarg(basename($f)).' ';
		}
		$arc  = $this-&gt;_options['archivers']['create'][$_GET['type']];
		$name = count($files) == 1 ? basename($files[0]) : $_GET['name'];
		$name = basename($this-&gt;_uniqueName($name.'.'.$arc['ext'], ''));
		
		$cwd = getcwd();
		chdir($dir);
		$cmd = $arc['cmd'].' '.$arc['argc'].' '.escapeshellarg($name).' '.$argc;
		exec($cmd, $o, $c);
		chdir($cwd);
		if (file_exists($dir.DIRECTORY_SEPARATOR.$name)) {
			$this-&gt;_content($dir);
			$this-&gt;_result['select'] = array($this-&gt;_hash($dir.DIRECTORY_SEPARATOR.$name));
		} else {
			$this-&gt;_result['error'] = 'Unable to create archive';
		}
	}
	
	/**
	 * Extract files from archive
	 *
	 * @return void
	 **/
	private function _extract()
	{
		if (empty($_GET['current']) 
		|| false == ($current = $this-&gt;_findDir(trim($_GET['current'])))
		|| empty($_GET['target'])
		|| false == ($file = $this-&gt;_find(trim($_GET['target']), $current))
		|| !$this-&gt;_isAllowed($current, 'write')
		) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		$this-&gt;_checkArchivers();
		$mime = $this-&gt;_mimetype($file);
		if (empty($this-&gt;_options['archivers']['extract'][$mime])) {
			return $this-&gt;_result['error'] = 'Invalid parameters';
		}
		$cwd = getcwd();
		$arc = $this-&gt;_options['archivers']['extract'][$mime];
		$cmd = $arc['cmd'].' '.$arc['argc'].' '.escapeshellarg(basename($file));
		chdir(dirname($file));
		exec($cmd, $o, $c);
		chdir($cwd);
		if ($c == 0) {
			$this-&gt;_content($current, true);
		} else {
			$this-&gt;_result['error'] = 'Unable to extract files from archive';
		}
	}
	
	
	/**
	 * Send header Connection: close. Required by safari to fix bug http://www.webmasterworld.com/macintosh_webmaster/3300569.htm
	 *
	 * @return void
	 **/
	private function _ping()
	{
		exit(header(&quot;Connection: close&quot;));
	}
	/************************************************************/
	/**                    &quot;content&quot; methods                   **/
	/************************************************************/
	/**
	 * Set current dir info, content and [dirs tree]
	 *
	 * @param  string  $path  current dir path
	 * @param  bool    $tree  set dirs tree?
	 * @return void
	 **/
	private function _content($path, $tree=false)
	{
		$this-&gt;_cwd($path);
		$this-&gt;_cdc($path);
		if ($tree) {
			$this-&gt;_result['tree'] = $this-&gt;_tree($this-&gt;_options['root']);
		}
	}

	/**
	 * Set current dir info
	 *
	 * @param  string  $path  current dir path
	 * @return void
	 **/
	private function _cwd($path)
	{
		$rel  = $this-&gt;_options['rootAlias'] ? $this-&gt;_options['rootAlias'] : basename($this-&gt;_options['root']);
		if ($path == $this-&gt;_options['root']) {
			$name = $rel;
		} else {
			$name = basename($path);
			$rel .= DIRECTORY_SEPARATOR.substr($path, strlen($this-&gt;_options['root'])+1);
		}
		$this-&gt;_result['cwd'] = array(
			'hash'       =&gt; $this-&gt;_hash($path),
			'name'       =&gt; $name,
			'mime'       =&gt; 'directory',
			'rel'        =&gt; $rel,
			'size'       =&gt; 0,
			'date'       =&gt; date($this-&gt;_options['dateFormat'], filemtime($path)),
			'read'       =&gt; true,
			'write'      =&gt; $this-&gt;_isAllowed($path, 'write'),
			'rm'         =&gt; $path == $this-&gt;_options['root'] ? false : $this-&gt;_isAllowed($path, 'rm')
			);
	}

	
	/**
	 * Set current dir content
	 *
	 * @param  string  $path  current dir path
	 * @return void
	 **/
	private function _cdc($path)
	{
		$dirs = $files = array();
		$ls = scandir($path);
		for ($i=0; $i &lt; count($ls); $i++) { 
			if ($this-&gt;_isAccepted($ls[$i])) {
				$info = $this-&gt;_info($path.DIRECTORY_SEPARATOR.$ls[$i]);
				if ($info['mime'] == 'directory') {
					$dirs[] = $info;
				} else {
					$files[] = $info;
				}
			}
		}
		$this-&gt;_result['cdc'] = array_merge($dirs, $files);
	}
	
	/**
	 * Return file/folder info
	 *
	 * @param  string  $path  file path
	 * @return array
	 **/
	private function _info($path)
	{
		$type = filetype($path);
		$stat =  $type == 'link' ? lstat($path) : stat($path);
		
		if ($stat['mtime'] &gt; $this-&gt;_today) {
			$d = 'Today '.date('H:i', $stat['mtime']);
		} elseif ($stat['mtime'] &gt; $this-&gt;_yesterday) {
			$d = 'Yesterday '.date('H:i', $stat['mtime']);
		} else {
			$d = date($this-&gt;_options['dateFormat'], $stat['mtime']);
		}
		
		$info = array(
			'name'  =&gt; htmlspecialchars(basename($path)),
			'hash'  =&gt; $this-&gt;_hash($path),
			'mime'  =&gt; $type == 'dir' ? 'directory' : $this-&gt;_mimetype($path),
			'date'  =&gt; $d, 
			'size'  =&gt; $type == 'dir' ? $this-&gt;_dirSize($path) : $stat['size'],
			'read'  =&gt; $this-&gt;_isAllowed($path, 'read'),
			'write' =&gt; $this-&gt;_isAllowed($path, 'write'),
			'rm'    =&gt; $this-&gt;_isAllowed($path, 'rm'),
			);
		
				
		if ($type == 'link') {
			if (false == ($lpath = $this-&gt;_readlink($path))) {
				$info['mime'] = 'symlink-broken';
				return $info;
			}
			if (is_dir($lpath)) {
				$info['mime']  = 'directory';
			} else {
				$info['parent'] = $this-&gt;_hash(dirname($lpath));
				$info['mime']   = $this-&gt;_mimetype($lpath);
			}
			$info['link']   = $this-&gt;_hash($lpath);
			$info['linkTo'] = ($this-&gt;_options['rootAlias'] ? $this-&gt;_options['rootAlias'] : basename($this-&gt;_options['root'])).substr($lpath, strlen($this-&gt;_options['root']));
			$info['read']   = $this-&gt;_isAllowed($lpath, 'read');
			$info['write']  = $this-&gt;_isAllowed($lpath, 'write');
			$info['rm']     = $this-&gt;_isAllowed($lpath, 'rm');
		} else {
			$lpath = '';
		}
		
		if ($info['mime'] != 'directory') {
			if ($this-&gt;_options['fileURL'] &amp;&amp; $info['read']) {
				$info['url'] = $this-&gt;_path2url($lpath ? $lpath : $path);
			}
			
			if (0 === ($p = strpos($info['mime'], 'image'))) {
				if (false != ($s = getimagesize($path))) {
					$info['dim'] = $s[0].'x'.$s[1];
				}
				if ($info['read']) {
					$info['resize'] = isset($info['dim']) &amp;&amp; $this-&gt;_canCreateTmb($info['mime']);
					$tmb = $this-&gt;_tmbPath($path);

					if (file_exists($tmb)) {
						$info['tmb']  = $this-&gt;_path2url($tmb);
					} elseif ($info['resize']) {
						$this-&gt;_result['tmb'] = true;
					}
					
				}
			}
		}
		return $info;
	}
	
	/**
	 * Return directory tree (multidimensional array)
	 *
	 * @param  string  $path  directory path
	 * @return array
	 **/
	private function _tree($path)
	{
		$dir = array(
			'hash'  =&gt; $this-&gt;_hash($path),
			'name'  =&gt; $path == $this-&gt;_options['root'] &amp;&amp; $this-&gt;_options['rootAlias'] ? $this-&gt;_options['rootAlias'] : basename($path),
			'read'  =&gt; $this-&gt;_isAllowed($path, 'read'),
			'write' =&gt; $this-&gt;_isAllowed($path, 'write'),
			'dirs'  =&gt; array()
			);
		
		if ($dir['read'] &amp;&amp; false != ($ls = scandir($path))) {
			for ($i=0; $i &lt; count($ls); $i++) {
				$p = $path.DIRECTORY_SEPARATOR.$ls[$i]; 
				if ($this-&gt;_isAccepted($ls[$i]) &amp;&amp; filetype($p) == 'dir') {
					$dir['dirs'][] = $this-&gt;_tree($p);
				}
			}
		}
		return $dir;
	}
	
	/************************************************************/
	/**                      fs methods                        **/
	/************************************************************/

	/**
	 * Return name for duplicated file/folder or new archive
	 *
	 * @param  string  $f       file/folder name
	 * @param  string  $suffix  file name suffix
	 * @return string
	 **/
	private function _uniqueName($f, $suffix=' copy')
	{
		$dir  = dirname($f);
		$name = basename($f);
		$ext = '';

		if (!is_dir($f)) {
			if (preg_match('/\.(tar\.gz|tar\.bz|tar\.bz2|[a-z0-9]{1,4})$/i', $name, $m)) {
				$ext = '.'.$m[1];
				$name = substr($name, 0,  strlen($name)-strlen($m[0]));
			}
		}
		
		if (preg_match('/('.$suffix.')(\d*)$/i', $name, $m)) {
			$i = (int)$m[2];
			$name = substr($name, 0, strlen($name)-strlen($m[2]));
		} else {
			$name .= $suffix;
			$i = 0;
			$n = $dir.DIRECTORY_SEPARATOR.$name.$ext;
			if (!file_exists($n)) {
				return $n;
			}
		}
		
		while ($i++ &lt;= 10000) {
			$n = $dir.DIRECTORY_SEPARATOR.$name.$i.$ext;
			if (!file_exists($n)) {
				return $n;
			}
		}
		return $dir.DIRECTORY_SEPARATOR.$name.md5($f).$ext;
	}

	/**
	 * Remove file or folder (recursively)
	 *
	 * @param  string  $path  fole/folder path
	 * @return void
	 **/
	private function _remove($path)
	{
		if (!$this-&gt;_isAllowed($path, 'rm')) {
			return $this-&gt;_errorData($path, 'Access denied');
		}
		if (!is_dir($path)) {
			if (!@unlink($path)) {
				$this-&gt;_errorData($path, 'Unable to remove file');
			} else {
				$this-&gt;_rmTmb($path);
			}
		} else {
			$ls = scandir($path);
			for ($i=0; $i &lt; count($ls); $i++) { 
				if ('.' != $ls[$i] &amp;&amp; '..' != $ls[$i]) {
					$this-&gt;_remove($path.DIRECTORY_SEPARATOR.$ls[$i]);
				}
			}
			if (!@rmdir($path)) {
				return $this-&gt;_errorData($path, 'Unable to remove file');
			}
		}
		return true;
	}
	
	/**
	 * Copy file/folder (recursively)
	 *
	 * @param  string  $src  file/folder to copy
	 * @param  string  $trg  destination name
	 * @return bool
	 **/
	private function _copy($src, $trg)
	{
		if (!$this-&gt;_isAllowed($src, 'read')) {
			return $this-&gt;_errorData($src, 'Access denied');
		}
		
		$dir = dirname($trg);
		
		if (!$this-&gt;_isAllowed($dir, 'write')) {
			return $this-&gt;_errorData($dir, 'Access denied');
		}
		if (file_exists($trg)) {
			return $this-&gt;_errorData($src, 'File or folder with the same name already exists');
		}
		
		if (!is_dir($src)) {
			if (!@copy($src, $trg)) {
				return $this-&gt;_errorData($src, 'Unable to copy files');
			} 
			@chmod($trg, $this-&gt;_options['fileMode']);
		} else {
			
			if (!@mkdir($trg, $this-&gt;_options['dirMode'])) {
				return $this-&gt;_errorData($src, 'Unable to copy files');
			}
			
			$ls = scandir($src);
			for ($i=0; $i &lt; count($ls); $i++) { 
				if ('.' != $ls[$i] &amp;&amp; '..' != $ls[$i]) {
					$_src = $src.DIRECTORY_SEPARATOR.$ls[$i];
					$_trg = $trg.DIRECTORY_SEPARATOR.$ls[$i];
					if (is_dir($_src)) {
						if (!$this-&gt;_copy($_src, $_trg)) {
							return $this-&gt;_errorData($_src, 'Unable to copy files');
						}
					} else {
						if (!@copy($_src, $_trg)) {
							return $this-&gt;_errorData($_src, 'Unable to copy files');
						}
						@chmod($_trg, $this-&gt;_options['fileMode']);
					}
				}
			}
		}
		return true;
	}
	
	/**
	 * Check new file name for invalid simbols. Return name if valid
	 *
	 * @return string  $n  file name
	 * @return string
	 **/
	private function _checkName($n)
	{
		$n = strip_tags(trim($n));
		if (!$this-&gt;_options['dotFiles'] &amp;&amp; '.' == substr($n, 0, 1)) {
			return false;
		}
		return preg_match('|^[^\\/\&lt;\&gt;:]+$|', $n) ? $n : false;
	}
	
	/**
	 * Find folder by hash in required folder and subfolders
	 *
	 * @param  string  $hash  folder hash
	 * @param  string  $path  folder path to search in
	 * @return string
	 **/
	private function _findDir($hash, $path='')
	{
		if (!$path) {
			$path = $this-&gt;_options['root'];
			if ($this-&gt;_hash($path) == $hash) {
				return $path;
			}
		}
		
		if (false != ($ls = scandir($path))) {
			for ($i=0; $i &lt; count($ls); $i++) { 
				$p = $path.DIRECTORY_SEPARATOR.$ls[$i];
				if ($this-&gt;_isAccepted($ls[$i]) &amp;&amp; is_dir($p)) {
					if ($this-&gt;_hash($p) == $hash || false != ($p = $this-&gt;_findDir($hash, $p))) {
						return $p;
					}
				}
			}
		}
	}
	
	/**
	 * Find file/folder by hash in required folder
	 *
	 * @param  string  $hash  file/folder hash
	 * @param  string  $path  folder path to search in
	 **/
	private function _find($hash, $path)
	{
		if (false != ($ls = scandir($path))) {
			for ($i=0; $i &lt; count($ls); $i++) { 
				if ($this-&gt;_isAccepted($ls[$i])) {
					$p = $path.DIRECTORY_SEPARATOR.$ls[$i];
					if ($this-&gt;_hash($p) == $hash) {
						return $p;
					}
				}
			}
		}
	}
	
	
	/**
	 * Return path of file on which link point to, if exists in root directory
	 *
	 * @param  string  $path  symlink path
	 * @return string
	 **/
	private function _readlink($path)
	{
		$target = readlink($path);
		if ('/' != substr($target, 0, 1)) {
			$target = dirname($path).DIRECTORY_SEPARATOR.$target;
		}
		$target = realpath($target);
		$root   = realpath($this-&gt;_options['root']);
		return $target &amp;&amp; file_exists($target) &amp;&amp; 0 === strpos($target, $root) ? $target : false;
	}
	
	/**
	 * Count total directory size if this allowed in options
	 *
	 * @param  string  $path  directory path
	 * @return int
	 **/
	private function _dirSize($path)
	{
		$size = 0;
		if (!$this-&gt;_options['dirSize'] || !$this-&gt;_isAllowed($path, 'read')) {
			return filesize($path);
		} 
		if (!isset($this-&gt;_options['du'])) {
			$this-&gt;_options['du'] = function_exists('exec')
				? exec('du -h '.escapeshellarg(__FILE__), $o, $s) &gt; 0 &amp;&amp; $s == 0
				: false;
		}
		if ($this-&gt;_options['du']) {
			$size = intval(exec('du -k '.escapeshellarg($path)))*1024;
		} else {
			$ls = scandir($path);
			for ($i=0; $i &lt; count($ls); $i++) { 
				if ($this-&gt;_isAccepted($ls[$i])) {
					$p = $path.DIRECTORY_SEPARATOR.$ls[$i];
					$size += filetype($p) == 'dir' &amp;&amp; $this-&gt;_isAllowed($p, 'read') ? $this-&gt;_dirSize($p) : filesize($p);
				}
			}
		}
		return $size;
	}
	
	/**
	 * Return file mimetype
	 *
	 * @param  string  $path  file path
	 * @return string
	 **/
	private function _mimetype($path)
	{
		if (empty($this-&gt;_options['mimeDetect']) || $this-&gt;_options['mimeDetect'] == 'auto') {
			$this-&gt;_options['mimeDetect'] = $this-&gt;_getMimeDetect();
		}
		
		switch ($this-&gt;_options['mimeDetect']) {
			case 'finfo':
				if (empty($this-&gt;_finfo)) {
					$this-&gt;_finfo = finfo_open(FILEINFO_MIME);
				}
				$type = @finfo_file($this-&gt;_finfo, $path);
				break;
			case 'php':   
			 	$type = mime_content_type($path);
				break;
			case 'linux':  
				$type = exec('file -ib '.escapeshellarg($path));
				break;
			case 'bsd':   
				$type = exec('file -Ib '.escapeshellarg($path));
				break;
			default:
				$pinfo = pathinfo($path); 
				$ext = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';
				$type = isset($this-&gt;_mimeTypes[$ext]) ? $this-&gt;_mimeTypes[$ext] : 'unknown;';
		}
		$type = explode(';', $type); 
		
		if ($this-&gt;_options['mimeDetect'] != 'internal' &amp;&amp; $type[0] == 'application/octet-stream') {
			$pinfo = pathinfo($path); 
			$ext = isset($pinfo['extension']) ? strtolower($pinfo['extension']) : '';
			if (!empty($ext) &amp;&amp; !empty($this-&gt;_mimeTypes[$ext])) {
				$type[0] = $this-&gt;_mimeTypes[$ext];
			}
		}
		
		return $type[0];
	}
	
	/************************************************************/
	/**                   image manipulation                   **/
	/************************************************************/

	/**
	 * Create image thumbnail
	 *
	 * @param  string  $img  image file
	 * @param  string  $tmb  thumbnail name
	 * @return bool
	 **/
	private function _tmb($img, $tmb)
	{
		if (false == ($s = getimagesize($img))) {
			return false;
		}
		$tmbSize = $this-&gt;_options['tmbSize'];
		switch ($this-&gt;_options['imgLib']) {
			case 'imagick':
				try {
					$_img = new imagick($img);
				} catch (Exception $e) {
					return false;
				}
				
				$_img-&gt;contrastImage(1);
				return $_img-&gt;cropThumbnailImage($tmbSize, $tmbSize) &amp;&amp; $_img-&gt;writeImage($tmb);
				break;
				
			case 'mogrify':
				if (@copy($img, $tmb)) {
					list($x, $y, $size) = $this-&gt;_cropPos($s[0], $s[1]);
					// exec('mogrify -crop '.$size.'x'.$size.'+'.$x.'+'.$y.' -scale '.$tmbSize.'x'.$tmbSize.'! '.escapeshellarg($tmb), $o, $c);
					exec('mogrify -resize '.$tmbSize.'x'.$tmbSize.'^ -gravity center -extent '.$tmbSize.'x'.$tmbSize.' '.escapeshellarg($tmb), $o, $c);
					
					if (file_exists($tmb)) {
						return true;
					} elseif ($c == 0) {
						// find tmb for psd and animated gif
						$mime = $this-&gt;_mimetype($img);
						if ($mime == 'image/vnd.adobe.photoshop' || $mime = 'image/gif') {
							$pinfo = pathinfo($tmb);
							$test = $pinfo['dirname'].DIRECTORY_SEPARATOR.$pinfo['filename'].'-0.'.$pinfo['extension'];
							if (file_exists($test)) {
								return rename($test, $tmb);
							}
						}
					}
				}
				break;
			
			case 'gd':
				if ($s['mime'] == 'image/jpeg') {
					$_img = imagecreatefromjpeg($img);
				} elseif ($s['mime'] == 'image/png') {
					$_img = imagecreatefrompng($img);
				} elseif ($s['mime'] == 'image/gif') {
					$_img = imagecreatefromgif($img);
				} 
				if (!$_img || false == ($_tmb = imagecreatetruecolor($tmbSize, $tmbSize))) {
					return false;
				}
				list($x, $y, $size) = $this-&gt;_cropPos($s[0], $s[1]);
				if (!imagecopyresampled($_tmb, $_img, 0, 0, $x, $y, $tmbSize, $tmbSize, $size, $size)) {
					return false;
				}
				$r = imagepng($_tmb, $tmb, 7);
				imagedestroy($_img);
				imagedestroy($_tmb);
				return $r;
				break;
		}
	}
	
	/**
	 * Remove image thumbnail
	 *
	 * @param  string  $img  image file
	 * @return void
	 **/
	private function _rmTmb($img)
	{
		if ($this-&gt;_options['tmbDir'] &amp;&amp; false != ($tmb = $this-&gt;_tmbPath($img)) &amp;&amp; file_exists($tmb)) {
			@unlink($tmb);
		}
	}
	
	/**
	 * Return x/y coord for crop image thumbnail
	 *
	 * @param  int  $w  image width
	 * @param  int  $h  image height	
	 * @return array
	 **/
	private function _cropPos($w, $h)
	{
		$x = $y = 0;
		$size = min($w, $h);
		if ($w &gt; $h) {
			$x = ceil(($w - $h)/2);
		} else {
			$y = ceil(($h - $w)/2);
		}
		return array($x, $y, $size);
	}
	
	/**
	 * Resize image
	 *
	 * @param  string  $img  image path
	 * @param  int     $w    image width
	 * @param  int     $h    image height
	 * @return bool
	 **/
	private function _resizeImg($img, $w, $h)
	{
		if (false == ($s = getimagesize($img))) {
			return false;
		}
		
		switch ($this-&gt;_options['imgLib']) {
			case 'imagick':
				if (false != ($_img = new imagick($img))) {
					return $_img-&gt;cropThumbnailImage($w, $h) &amp;&amp; $_img-&gt;writeImage($img);
				}
				break;
			case 'mogrify':
				exec('mogrify -scale '.$w.'x'.$h.'! '.escapeshellarg($img), $o, $c);
				return 0 == $c;
				break;
			case 'gd':
				if ($s['mime'] == 'image/jpeg') {
					$_img = imagecreatefromjpeg($img);
				} elseif ($s['mime'] = 'image/png') {
					$_img = imagecreatefrompng($img);
				} elseif ($s['mime'] = 'image/gif') {
					$_img = imagecreatefromgif($img);
				} 
				if (!$_img || false == ($_out = imagecreatetruecolor($w, $h))) {
					return false;
				}
				if (!imagecopyresampled($_out, $_img, 0, 0, 0, 0, $w, $h, $s[0], $s[1])) {
					return false;
				}
				if ($s['mime'] == 'image/jpeg') {
					$r = imagejpeg($_out, $img, 100);
				} else if ($s['mime'] = 'image/png') {
					$r = imagepng($_out, $img, 7);
				} else {
					$r = imagegif($_out, $img, 7);
				}
				imagedestroy($_img);
				imagedestroy($_out);
				return $r;
				break;
		}
				
		
	}
	
	/**
	 * Return true if we can create thumbnail for file with this mimetype
	 *
	 * @param  string  $mime  file mimetype
	 * @return bool
	 **/
	private function _canCreateTmb($mime)
	{
		if ($this-&gt;_options['tmbDir'] &amp;&amp; $this-&gt;_options['imgLib'] &amp;&amp; 0 === strpos($mime, 'image')) {
			if ('gd' == $this-&gt;_options['imgLib']) {
				return $mime == 'image/jpeg' || $mime == 'image/png' || $mime == 'image/gif';
			}
			return true;
		}
	}
	
	/**
	 * Return image thumbnail path. For thumbnail return itself 
	 *
	 * @param  string  $path  image path
	 * @return string
	 **/
	private function _tmbPath($path)
	{
		$tmb = '';
		if ($this-&gt;_options['tmbDir']) {
			$tmb = dirname($path) != $this-&gt;_options['tmbDir']
				? $this-&gt;_options['tmbDir'].DIRECTORY_SEPARATOR.$this-&gt;_hash($path).'.png'
				: $path;
		}
		return $tmb;
	}
	
	/************************************************************/
	/**                       access control                   **/
	/************************************************************/
	
	/**
	 * Return true if file's mimetype is allowed for upload
	 *
	 * @param  string  $name    file name
	 * @param  string  $tmpName uploaded file tmp name
	 * @return bool
	 **/
	private function _isUploadAllow($name, $tmpName)
	{
		$mime  = $this-&gt;_mimetype($this-&gt;_options['mimeDetect'] != 'internal' ? $tmpName : $name);
		$allow = false;
		$deny  = false;

		if (in_array('all', $this-&gt;_options['uploadAllow'])) {
			$allow = true;
		} else {
			foreach ($this-&gt;_options['uploadAllow'] as $type) {
				if (0 === strpos($mime, $type)) {
					$allow = true;
					break;
				}
			}
		}
		
		if (in_array('all', $this-&gt;_options['uploadDeny'])) {
			$deny = true;
		} else {
			foreach ($this-&gt;_options['uploadDeny'] as $type) {
				if (0 === strpos($mime, $type)) {
					$deny = true;
					break;
				}
			}
		}
		return 0 === strpos($this-&gt;_options['uploadOrder'], 'allow') ? $allow &amp;&amp; !$deny : $allow || !$deny;
	}

	/**
	 * Return true if file name is not . or ..
	 * If file name begins with . return value according to $this-&gt;_options['dotFiles']
	 *
	 * @param  string  $file  file name
	 * @return bool
	 **/
	private function _isAccepted($file)
	{
		if ('.' == $file || '..' == $file) {
			return false;
		}
		if (!$this-&gt;_options['dotFiles'] &amp;&amp; '.' == substr($file, 0, 1)) {
			return false;
		}
		return true;
	}

	/**
	 * Return true if requeired action allowed to file/folder
	 *
	 * @param  string  $path    file/folder path
	 * @param  string  $action  action name (read/write/rm)
	 * @return void
	 **/
	private function _isAllowed($path, $action) {
		
		switch ($action) {
			case 'read':
				if (!is_readable($path)) {
					return false;
				}
				break;
			case 'write':
				if (!is_writable($path)) {
					return false;
				}
				break;
			case 'rm':
				if (!is_writable(dirname($path))) {
					return false;
				}
				break;
		}
		
		// if ($this-&gt;_options['aclObj']) {
		// 	
		// }
		$path = substr($path, strlen($this-&gt;_options['root'])+1);
		// echo &quot;$path\n&quot;;
		foreach ($this-&gt;_options['perms'] as $regex =&gt; $rules) {
			
			if (preg_match($regex, $path)) {
				if (isset($rules[$action])) {
					return $rules[$action];
				}
			}
		}
		return isset($this-&gt;_options['defaults'][$action]) ? $this-&gt;_options['defaults'][$action] : false;
	}
	
	/************************************************************/
	/**                          utilites                      **/
	/************************************************************/
	
	/**
	 * Return image manipalation library name
	 *
	 * @return string
	 **/
	private function _getImgLib()
	{
		if (extension_loaded('imagick')) {
			return 'imagick';
		} elseif (function_exists('exec')) {
			exec('mogrify --version', $o, $c);
			if ($c == 0) {
				return 'mogrify';
			}
		}
		return function_exists('gd_info') ? 'gd' : '';
	}
	
	/**
	 * Return list of available archivers
	 *
	 * @return array
	 **/
	private function _checkArchivers()
	{
		if (!function_exists('exec')) {
			$this-&gt;_options['archivers'] = $this-&gt;_options['archive'] = array();
			return;
		}
		$arcs = array(
			'create'  =&gt; array(),
			'extract' =&gt; array()
			);
		
		exec('tar --version', $o, $ctar);
		if ($ctar == 0) {
			$arcs['create']['application/x-tar']  = array('cmd' =&gt; 'tar', 'argc' =&gt; '-cf', 'ext' =&gt; 'tar');
			$arcs['extract']['application/x-tar'] = array('cmd' =&gt; 'tar', 'argc' =&gt; '-xf', 'ext' =&gt; 'tar');
			$test = exec('gzip --version', $o, $c);
			if ($c == 0) {
				$arcs['create']['application/x-gzip']  = array('cmd' =&gt; 'tar', 'argc' =&gt; '-czf', 'ext' =&gt; 'tgz');
				$arcs['extract']['application/x-gzip'] = array('cmd' =&gt; 'tar', 'argc' =&gt; '-xzf', 'ext' =&gt; 'tgz');
			}
			$test = exec('bzip2 --version', $o, $c);
			if ($c == 0) {
				$arcs['create']['application/x-bzip2']  = array('cmd' =&gt; 'tar', 'argc' =&gt; '-cjf', 'ext' =&gt; 'tbz');
				$arcs['extract']['application/x-bzip2'] = array('cmd' =&gt; 'tar', 'argc' =&gt; '-xjf', 'ext' =&gt; 'tbz');
			}
		}
		
		exec('zip --version', $o, $c);
		if ($c == 0) {
			$arcs['create']['application/zip']  = array('cmd' =&gt; 'zip', 'argc' =&gt; '-r9', 'ext' =&gt; 'zip');
		}
		
		exec('unzip --help', $o, $c);
		if ($c == 0) {
			$arcs['extract']['application/zip'] = array('cmd' =&gt; 'unzip', 'argc' =&gt; '',  'ext' =&gt; 'zip');
		} 
		
		exec('rar --version', $o, $c);
		if ($c == 0) {
			$arcs['create']['application/x-rar']  = array('cmd' =&gt; 'rar', 'argc' =&gt; 'a inul', 'ext' =&gt; 'rar');
			$arcs['extract']['application/x-rar'] = array('cmd' =&gt; 'rar', 'argc' =&gt; 'x',      'ext' =&gt; 'rar');
		} else {
			$test = exec('unrar', $o, $c);
			if ($c==0 || $c == 7) {
				$arcs['extract']['application/x-rar'] = array('cmd' =&gt; 'unrar', 'argc' =&gt; 'x', 'ext' =&gt; 'rar');
			}
		}
		
		exec('7za --help', $o, $c);
		if ($c == 0) {
			$arcs['create']['application/x-7z-compressed']  = array('cmd' =&gt; '7za', 'argc' =&gt; 'a', 'ext' =&gt; '7z');
			$arcs['extract']['application/x-7z-compressed'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'e -y', 'ext' =&gt; '7z');
			
			if (empty($arcs['create']['application/x-gzip'])) {
				$arcs['create']['application/x-gzip'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'a -tgzip', 'ext' =&gt; 'tar.gz');
			}
			if (empty($arcs['extract']['application/x-gzip'])) {
				$arcs['extract']['application/x-gzip'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'e -tgzip -y', 'ext' =&gt; 'tar.gz');
			}
			if (empty($arcs['create']['application/x-bzip2'])) {
				$arcs['create']['application/x-bzip2'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'a -tbzip2', 'ext' =&gt; 'tar.bz');
			}
			if (empty($arcs['extract']['application/x-bzip2'])) {
				$arcs['extract']['application/x-bzip2'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'a -tbzip2 -y', 'ext' =&gt; 'tar.bz');
			}
			if (empty($arcs['create']['application/zip'])) {
				$arcs['create']['application/zip'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'a -tzip -l', 'ext' =&gt; 'zip');
			}
			if (empty($arcs['extract']['application/zip'])) {
				$arcs['extract']['application/zip'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'e -tzip -y', 'ext' =&gt; 'zip');
			}
			if (empty($arcs['create']['application/x-tar'])) {
				$arcs['create']['application/x-tar'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'a -ttar -l', 'ext' =&gt; 'tar');
			}
			if (empty($arcs['extract']['application/x-tar'])) {
				$arcs['extract']['application/x-tar'] = array('cmd' =&gt; '7za', 'argc' =&gt; 'e -ttar -y', 'ext' =&gt; 'tar');
			}
		}
		
		$this-&gt;_options['archivers'] = $arcs;
		foreach ($this-&gt;_options['archiveMimes'] as $k=&gt;$mime) {
			if (!isset($this-&gt;_options['archivers']['create'][$mime])) {
				unset($this-&gt;_options['archiveMimes'][$k]);
			}
		}
		if (empty($this-&gt;_options['archiveMimes'])) {
			$this-&gt;_options['archiveMimes'] = array_keys($this-&gt;_options['archivers']['create']);
		}
	}
	
	
	/**
	 * Return mimetype detect method name
	 *
	 * @return string
	 **/
	private function _getMimeDetect()
	{
		if (in_array('finfo',  get_declared_classes())) {
			return 'finfo';
		} elseif (function_exists('mime_content_type') &amp;&amp; (mime_content_type(__FILE__) == 'text/x-php' || mime_content_type(__FILE__) == 'text/x-c++')) {
			return 'mime_content_type';
		} elseif (function_exists('exec')) {
			$type = exec('file -ib '.escapeshellarg(__FILE__));
			if (0 === strpos($type, 'text/x-php') || 0 === strpos($type, 'text/x-c++'))
			{
				return 'linux';
			}
			$type = exec('file -Ib '.escapeshellarg(__FILE__));
			if (0 === strpos($type, 'text/x-php') || 0 === strpos($type, 'text/x-c++'))
			{
				return 'bsd';
			}
		}
		return 'internal';
	}
	
	
	/**
	 * Return file path hash
	 *
	 * @param  string  $path 
	 * @return string
	 **/
	private function _hash($path)
	{
		return md5($path);
	}
	
	/**
	 * Return file URL
	 *
	 * @param  string  $path 
	 * @return string
	 **/
	private function _path2url($path)
	{
		$dir  = substr(dirname($path), strlen($this-&gt;_options['root'])+1);
		$file = rawurlencode(basename($path));
		return $this-&gt;_options['URL'].($dir ? str_replace(DIRECTORY_SEPARATOR, '/', $dir).'/' : '').$file;
	}
	
	/**
	 * Paack error message in $this-&gt;_result['errorData']
	 *
	 * @param string  $path  path to file
	 * @param string  $msg   error message
	 * @return bool always false
	 **/
	private function _errorData($path, $msg)
	{
		$path = preg_replace('|^'.preg_quote($this-&gt;_options['root']).'|', $this-&gt;_fakeRoot, $path);
		if (!isset($this-&gt;_result['errorData'])) {
			$this-&gt;_result['errorData'] = array();
		}
		$this-&gt;_result['errorData'][$path] = $msg;
		return false;
	}	
	
	private function _utime()
	{
		$time = explode(&quot; &quot;, microtime());
		return (double)$time[1] + (double)$time[0];
	}	
	
}


?&gt;
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>